.. include:: ../substitutions.rst

**************
Postprocessing
**************

.. _postprocess-tldr:

TL;DR
=====

The ``postprocess.py`` command-line tool can be used to analyze the results generated by ``match_template.py``.

.. code-block:: bash

    postprocess.py --help

.. tab-set::

    .. tab-item:: Orientations

        Executing the following code will generate a tab-separated file named `output.tsv` with eight columns. The z, y and x column correspond to the translation, the euler_z, euler_y and euler_x column to the rotation used to obtain the column score. The detail column provides some additional information based on the process with which the peaks were generated.

        At most 1,000 peaks top scoring that are separated by at least 20 voxel and no less than 30 voxel distanced from the boundaries of the target will be written to disk when executing the following from within the shell:

        .. code-block:: bash

            postprocess.py \
                --input_file output.pickle \
                --output_prefix output \
                --output_format orientations \
                --min_distance 30 \
                --min_boundary_distance 20\
                --number_of_peaks 1000

        .. note::

            |project| uses the zyx convention, like the CCP4/MRC format. In `IMOD <https://bio3d.colorado.edu/imod/>`_ terms, a file read by :py:meth:`tme.density.Density.from_file` with data shape 500, 928, 960, will contain 960 columns, 928 rows and 500 sections. Similarly, the reported Euler angles are in intrinsic zyx convention (see :py:meth:`tme.matching_utils.euler_to_rotationmatrix` for reference).

    .. tab-item:: Alignments

        Executing the following code will align the template to the target used in ``match_template.py`` based on high-scoring orientations. These high-scoring orientations are written to disk, either as atomic structure or density depending on which was used as input for ``match_template.py``. The generated files follow the naming pattern {output_prefix}_{index}.{extension}. In the following example output_prefix would be output. Index 0 corresponds to the orientation with highest score, index 1 to the second largest and so on. Extension corresponds to the file extension of the template used in ``match_template.py``.

        The following will write at most ten top scoring alignments
        to disk.

        .. code-block:: bash

            postprocess.py \
                --input_file output.pickle \
                --output_prefix output \
                --output_format alignment \
                --number_of_peaks 10

    .. tab-item:: Extraction

        Executing the following code will extract regions from the target with the dimension of the template used in ``match_template.py``. The output can be used for averaging, i.e. subtomograms, or alignment. The generated files follow the naming pattern {output_prefix}_{index}.mrc. In the following example output_prefix would be output. Index 0 corresponds to the orientation with highest score, index 1 to the second largest and so on.

        The following will write at most 500 top scoring peaks separated by a distance of 20 voxel that have been identified using :py:class:`tme.analyzer.PeakCallerMaximumFilter` to disk.

        .. code-block:: bash

            postprocess.py \
                --input_file output.pickle \
                --output_prefix output \
                --output_format extraction \
                --min_distance 20 \
                --number_of_peaks 500 \
                --peak_caller PeakCallerMaximumFilter

    .. tab-item:: Relion

        This option will generate a `STAR <https://en.wikipedia.org/wiki/Self-defining_Text_Archive_and_Retrieval>`_ file and extract subtomograms which can be directly used input for reconstruction, refinement and downstream classification with `RELION <https://github.com/3dem/relion>`_. In terms of peak calling and subtomogram extraction, this option performs identical to the output_format ``extraction``. The output STAR file consists of an optics group block which contains informations about the imaging conditions, pixel size, and another data group with tab separated columns containing x, y, z coordinates (in voxels), a file path to the generated cropped subtomogram file, the Euler angles, namely rotation, tilt and psi.

        The output is compatible with RELION 4.0 and was tested with relion_reconstruct, and relion_refine_mpi.

        .. code-block:: bash

            postprocess.py \
                --input_file output.pickle \
                --output_prefix output \
                --output_format relion \
                --min_distance 20 \
                --number_of_peaks 1000 \
                -—wedge_mask mask.mrc

        .. note::

            Without a wedge mask or a fully fledged CTF, the averages computed by `RELION <https://github.com/3dem/relion>`_ might be overly distorted due to preferential alignment of subtomograms on the missing wedge. Wedge mask can be generated with |project| (see :py:meth:`tme.preprocessor.Preprocessor.wedge_mask` and :py:meth:`tme.preprocessor.Preprocessor.continuous_wedge_mask`) or the Napari GUI (see :ref:`preprocessing section <filter-application>`).

            ``postprocess.py`` automatically pads the extracted subtomograms to an even number of voxels in each dimension to avoid potential RELION crashes.

    .. tab-item:: Average

        Executing the following code will extract regions around the identified candidates and compute a simple average using the corresponding rotations.

        .. code-block:: bash

            postprocess.py \
                --input_file output.pickle \
                --output_prefix average \
                --output_format average \
                --min_distance 20 \
                --number_of_peaks 500 \
                --peak_caller PeakCallerMaximumFilter


You can find an overview of available peak calling methods :ref:`here <analyzer-label>`.

Background
==========

Postprocessing identifies regions of high similarity from the template matching output, which we refer to as peaks. Each peak corresponds to an occurence of the template in the target, which is fully characterized by a translation vector, a rotation, a score and additional data column.

To better understand this, lets recall an example from the :ref:`Preprocessing section <preprocess-filtering>`. Generally, high scores indicate regions of high similarity, and most scoring functions are limited to the interval [0, 1], with 1 being a perfect match (see :doc:`exhaustive template matching <../reference/matching_exhaustive>` for details on your specific scoring method).

.. plot::

    import copy
    import numpy as np
    import matplotlib.pyplot as plt
    import matplotlib.patches as patches
    from skimage.feature import match_template

    from tme import Density

    target = Density.from_file("../_static/examples/preprocessing_target.png").data
    template = Density.from_file("../_static/examples/preprocessing_template.png").data

    result = match_template(target, template, pad_input=True)
    ij = np.unravel_index(np.argmax(result), result.shape)
    x, y = ij[::-1]

    fig, ax = plt.subplots(nrows=1, ncols=1)
    ax.imshow(result)
    ax.set_title('Template Matching Score', color='#0a7d91')

    square_size = max(template.shape)
    rect = patches.Rectangle((x - square_size / 2, y - square_size / 2), square_size, square_size, edgecolor='red', facecolor='none')
    ax.add_patch(rect)

    plt.tight_layout()
    plt.show()

The score peak is located within the red rectangle at 111, 240. Therefore, the maximum similariy is obtained when translating the template so that its center of mass is at position 111, 240. This convention used in |project| to represent in scores and candidates is analogous to other tools and figuratively explained in a `skimage tutorial <https://scikit-image.org/docs/stable/auto_examples/features_detection/plot_template.html>`_. The corresponding rotation matrix for this peak is the identity matrix.

The following sections explain the output of ``match_template.py`` and outline the peak calling procedure used by ``postprocess.py``.


Template Matching Output
========================

``match_template.py`` evaluates the similarity between target and template along all rotational and translation degrees of freedom. The output is a `pickle <https://docs.python.org/3/library/pickle.html>`_ file, whose content depends on the corresponding analyzer. The `pickle <https://docs.python.org/3/library/pickle.html>`_ file can be read using :py:meth:`tme.matching_utils.load_pickle`. For the default analyzer :py:class:`tme.analyzer.MaxScoreOverRotations`, it contains five objects:

- **Scores**: An array with scores mapped to translations.
- **Offset**: Offset informing about shifts in coordinate sytems.
- **Rotations**: An array of optimal rotation indices for each translation.
- **Rotation Dictionary**: Mapping of rotation indices to rotation matrix bytestrings.
- **Metadata**: Coordinate system information and parameters for reproducibility.

However, when you use the `-p` flag with ``match_template.py``, the output structure differs. The flag triggers direct peak calling, altering the output to:

- **Translations**: A numpy array containing translations of peaks.
- **Rotations**: A numpy array containing rotations of peaks.
- **Scores**: Score of each peak.
- **Details**: Additional information regarding each peak.
- **Metadata**: Coordinate system information and parameters for reproducibility.

.. note::
    In general, all but the last element of the created output pickle will correspond to return value of a given :doc:`analyzer <../reference/analyzer>`'s merge method.


Usage Examples
==============

The following outlines how to use the output of ``postprocessing.py``'s ``output_format`` orientations for the previous section's :ref:`Usage Examples <match-template-usage-examples>`. We assume the generated orientations file is named ``output.tsv``.

.. tab-set::

    .. tab-item:: Particle Picking

        The code block below will identify no more than 1000 peaks, that are sufficiently distanced from the edges of the tomogram and maintain an individual distance of 30 voxels.

        .. code-block:: bash

            postprocess.py \
                --input_file output.pickle \
                --output_prefix output \
                --output_format orientations \
                --min_distance 30 \
                --mask_edges \
                --number_of_peaks 1000

        If you are not sure about the number of peaks in your data, you can set score cutoffs using ``--minimum_score`` and ``--maximum_score``, or have the minimum score automatically determined using ``--n_false_positives``.

        Picked particles are typically assessed manually, which is supported by the napari GUI shipped with |project| (:ref:`installation <gui-installation>`, :ref:`usage <filter-application>`). To showcase the GUI, we are going to utilze particle picks generated on the tomogram TS_037 [1]_. Launch the GUI application, drag and drop the tomogram into the viewer and subseqeuently use the ``Import Point Cloud`` button to select and import the result from ``postprocess.py``. Points are colored according to the Turbo colorscale, from low scores in blue to high scores in red.

        .. figure:: ../_static/examples/napari_pointcloud_widget_intro.png
            :width: 100 %
            :align: center

        Using the controls outlined in blue, we can remove particles from the set by using the delete key. If you would like to change the color, size, or shape of the particles, you can select everything by clicking on the particle layer followed by Shift + A. Pressing Shift + A again clears the selection.

        Once you have removed particles that were deemed unreliable by manual inspection, you can export the remaining points using the `Export Point Cloud button`. This will generate an orientations tsv file anaologous to ``output_format`` orientations in ``postprocess.py``. Assume you generated a file called ``filtered_orientations.tsv`` you can pass it to ``postprocess.py`` using the ``--orientations``

        .. code-block:: bash

            postprocess.py \
                --input_file output.pickle \
                --output_prefix output \
                --output_format extraction \
                --orientations filtered_orientations.tsv

        Executing the code above will extract all subtomograms from the filtered orientations file.


    .. tab-item:: Fit Atomic Structure

        Note, the code example below is equivalent to using ``postprocess.py`` with ``output_format`` alignment and serves an illustrative purpose.

        For this case, its common to inspect the positioning of the initial structure after translation and rotation in the electron density. The following transforms the initial structure and writes the top ten highest scoring orientations to disk.

        .. code-block:: python

            import pickle

            import numpy as np

            from tme import Density, Structure
            from tme.matching_utils import euler_to_rotationmatrix, load_pickle

            # Load and extract orientations
            orientations = []
            with open("output.tsv", mode = "r", encoding = "utf-8") as infile:
                data = infile.read().split("\n")

            # Remove header
            _ = data.pop(0)

            # Get coordinate system information
            target_origin, _, sampling_rate, meta = load_pickle("output.pickle").pop()

            # Convert string to floating point
            for orientation in data:
                orientation = orientation.split("\t")
                if len(orientation) == 1:
                    continue
                orientations.append([float(x) for x in orientation])

            # Load template and compute center of mass
            initial_structure = Structure.from_file("5UZ4.pdb")
            center_of_mass = initial_structure.center_of_mass()[::-1]

            # Generate candidates and write to disk
            n_candidates = min(10, len(orientations))
            for i in range(n_candidates):
                orientation = orientations[i]
                translation, rotation = orientation[0:3], orientation[3:6]
                translation = np.subtract(
                    np.multiply(translation, sampling_rate),
                    center_of_mass,
                )
                translation = np.add(translation, target_origin)
                rotation_matrix = euler_to_rotationmatrix(rotation)
                transformed_structure = initial_structure.rigid_transform(
                    translation = translation[::-1],
                    rotation_matrix = rotation_matrix[::-1, ::-1]
                )
                transformed_structure.to_file(f"{i}.pdb")

        .. note::

            Thoe operation outlined above is equivalent to using ``postprocess.py`` with ``output_format`` alignment.


    .. tab-item:: Alignment of Densities

        Note, the code example below is equivalent to using ``postprocess.py`` with ``output_format`` alignment and serves an illustrative purpose.

        The following transforms the initial density and writes the top ten highest scoring orientations to disk.

        .. code-block:: python

            import pickle

            import numpy as np

            from tme import Density
            from tme.matching_utils import euler_to_rotationmatrix, load_pickle

            # Load and extract orientations
            orientations = []
            with open("output.tsv", mode = "r", encoding = "utf-8") as infile:
                data = infile.read().split("\n")

            # Remove header
            _ = data.pop(0)

            # Get coordinate system information
            target_origin, _, sampling_rate, meta = load_pickle("output.pickle").pop()

            # Convert string to floating point
            for orientation in data:
                orientation = orientation.split("\t")
                if len(orientation) == 1:
                    continue
                orientations.append([float(x) for x in orientation])

            # Load template and compute center of mass
            initial_density = Density.from_file("emd_8621_transformed.mrc")
            initial_density, _ = initial_density.centered(0)
            center_of_mass = initial_density.center_of_mass(initial_density.data)

            n_candidates = min(10, len(orientations))
            for i in range(n_candidates):
                orientation = orientations[i]
                translation, rotation = orientation[0:3], orientation[3:6]
                translation = np.subtract(translation, center_of_mass)
                rotation_matrix = euler_to_rotationmatrix(rotation)
                transformed_density = initial_density.rigid_transform(
                    rotation_matrix = rotation_matrix
                )
                new_origin = np.add(target_origin / sampling_rate, translation)
                transformed_density.origin = np.multiply(new_origin, sampling_rate)
                transformed_density.to_file(f"{i}.mrc")


Troubleshooting
===============

The most insightful piece of information for troubleshooting are the computed scores, and their corresponding orientations. Assuming ``match_template.py`` generated a file ``output.pickle``, you can directly import it into the GUI using the ``Import Pickle`` button. Alternatively, you can write the scores and rotations to disk for subsequent analysis in a a macromolecular viewer of your choice. For reference, you can have a look at the :ref:`preprocessing section <preprocess-filtering>` to assess whether your results are reminiscent of examples there.

.. code-block:: python

    from tme import Density
    from tme.matching_utils import load_pickle

    # Loading ``match_template.py`` output.
    data = load_pickle("output.pickle")

    scores, offset, rotations, rotation_mapping, *_ = data

    Density(scores).to_file("scores.mrc")
    Density(rotations).to_file("rotations.mrc")


If no examples match your particular case, please feel free to open an `issue <https://github.com/KosinskiLab/pyTME.git>`_.


References
==========

.. [1] de Teresa-Trueba, I. et al. Nat. Methods 2023, 20, 284–294.
